/*
 * NamSor API v2
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it! 
 *
 * The version of the OpenAPI document: 2.0.27
 * Contact: contact@namsor.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.namsor.sdk2.api;

import com.namsor.sdk2.invoke.ApiCallback;
import com.namsor.sdk2.invoke.ApiClient;
import com.namsor.sdk2.invoke.ApiException;
import com.namsor.sdk2.invoke.ApiResponse;
import com.namsor.sdk2.invoke.Configuration;
import com.namsor.sdk2.invoke.Pair;
import com.namsor.sdk2.invoke.ProgressRequestBody;
import com.namsor.sdk2.invoke.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.namsor.sdk2.model.BatchCorridorIn;
import com.namsor.sdk2.model.BatchCorridorOut;
import com.namsor.sdk2.model.BatchFirstLastNameDiasporaedOut;
import com.namsor.sdk2.model.BatchFirstLastNameGenderedOut;
import com.namsor.sdk2.model.BatchFirstLastNameGeoIn;
import com.namsor.sdk2.model.BatchFirstLastNameGeoSubclassificationOut;
import com.namsor.sdk2.model.BatchFirstLastNameGeoSubdivisionIn;
import com.namsor.sdk2.model.BatchFirstLastNameGeoZippedIn;
import com.namsor.sdk2.model.BatchFirstLastNameIn;
import com.namsor.sdk2.model.BatchFirstLastNameOriginedOut;
import com.namsor.sdk2.model.BatchFirstLastNameReligionedOut;
import com.namsor.sdk2.model.BatchFirstLastNameUSRaceEthnicityOut;
import com.namsor.sdk2.model.BatchPersonalNameGenderedOut;
import com.namsor.sdk2.model.BatchPersonalNameGeoIn;
import com.namsor.sdk2.model.BatchPersonalNameGeoOut;
import com.namsor.sdk2.model.BatchPersonalNameGeoSubclassificationOut;
import com.namsor.sdk2.model.BatchPersonalNameGeoSubdivisionIn;
import com.namsor.sdk2.model.BatchPersonalNameIn;
import com.namsor.sdk2.model.BatchPersonalNameParsedOut;
import com.namsor.sdk2.model.BatchPersonalNameReligionedOut;
import com.namsor.sdk2.model.CorridorOut;
import com.namsor.sdk2.model.FirstLastNameDiasporaedOut;
import com.namsor.sdk2.model.FirstLastNameGenderedOut;
import com.namsor.sdk2.model.FirstLastNameGeoSubclassificationOut;
import com.namsor.sdk2.model.FirstLastNameOriginedOut;
import com.namsor.sdk2.model.FirstLastNameReligionedOut;
import com.namsor.sdk2.model.FirstLastNameUSRaceEthnicityOut;
import com.namsor.sdk2.model.PersonalNameGenderedOut;
import com.namsor.sdk2.model.PersonalNameGeoOut;
import com.namsor.sdk2.model.PersonalNameParsedOut;
import com.namsor.sdk2.model.PersonalNameReligionedOut;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class PersonalApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PersonalApi() {
        this(Configuration.getDefaultApiClient());
    }

    public PersonalApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for corridor
     * @param countryIso2From  (required)
     * @param firstNameFrom  (required)
     * @param lastNameFrom  (required)
     * @param countryIso2To  (required)
     * @param firstNameTo  (required)
     * @param lastNameTo  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Two classified names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call corridorCall(String countryIso2From, String firstNameFrom, String lastNameFrom, String countryIso2To, String firstNameTo, String lastNameTo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/corridor/{countryIso2From}/{firstNameFrom}/{lastNameFrom}/{countryIso2To}/{firstNameTo}/{lastNameTo}"
            .replace("{" + "countryIso2From" + "}", localVarApiClient.escapeString(countryIso2From.toString()))
            .replace("{" + "firstNameFrom" + "}", localVarApiClient.escapeString(firstNameFrom.toString()))
            .replace("{" + "lastNameFrom" + "}", localVarApiClient.escapeString(lastNameFrom.toString()))
            .replace("{" + "countryIso2To" + "}", localVarApiClient.escapeString(countryIso2To.toString()))
            .replace("{" + "firstNameTo" + "}", localVarApiClient.escapeString(firstNameTo.toString()))
            .replace("{" + "lastNameTo" + "}", localVarApiClient.escapeString(lastNameTo.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call corridorValidateBeforeCall(String countryIso2From, String firstNameFrom, String lastNameFrom, String countryIso2To, String firstNameTo, String lastNameTo, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryIso2From' is set
        if (countryIso2From == null) {
            throw new ApiException("Missing the required parameter 'countryIso2From' when calling corridor(Async)");
        }

        // verify the required parameter 'firstNameFrom' is set
        if (firstNameFrom == null) {
            throw new ApiException("Missing the required parameter 'firstNameFrom' when calling corridor(Async)");
        }

        // verify the required parameter 'lastNameFrom' is set
        if (lastNameFrom == null) {
            throw new ApiException("Missing the required parameter 'lastNameFrom' when calling corridor(Async)");
        }

        // verify the required parameter 'countryIso2To' is set
        if (countryIso2To == null) {
            throw new ApiException("Missing the required parameter 'countryIso2To' when calling corridor(Async)");
        }

        // verify the required parameter 'firstNameTo' is set
        if (firstNameTo == null) {
            throw new ApiException("Missing the required parameter 'firstNameTo' when calling corridor(Async)");
        }

        // verify the required parameter 'lastNameTo' is set
        if (lastNameTo == null) {
            throw new ApiException("Missing the required parameter 'lastNameTo' when calling corridor(Async)");
        }

        return corridorCall(countryIso2From, firstNameFrom, lastNameFrom, countryIso2To, firstNameTo, lastNameTo, _callback);

    }

    /**
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param countryIso2From  (required)
     * @param firstNameFrom  (required)
     * @param lastNameFrom  (required)
     * @param countryIso2To  (required)
     * @param firstNameTo  (required)
     * @param lastNameTo  (required)
     * @return CorridorOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Two classified names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public CorridorOut corridor(String countryIso2From, String firstNameFrom, String lastNameFrom, String countryIso2To, String firstNameTo, String lastNameTo) throws ApiException {
        ApiResponse<CorridorOut> localVarResp = corridorWithHttpInfo(countryIso2From, firstNameFrom, lastNameFrom, countryIso2To, firstNameTo, lastNameTo);
        return localVarResp.getData();
    }

    /**
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param countryIso2From  (required)
     * @param firstNameFrom  (required)
     * @param lastNameFrom  (required)
     * @param countryIso2To  (required)
     * @param firstNameTo  (required)
     * @param lastNameTo  (required)
     * @return ApiResponse&lt;CorridorOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Two classified names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CorridorOut> corridorWithHttpInfo(String countryIso2From, String firstNameFrom, String lastNameFrom, String countryIso2To, String firstNameTo, String lastNameTo) throws ApiException {
        okhttp3.Call localVarCall = corridorValidateBeforeCall(countryIso2From, firstNameFrom, lastNameFrom, countryIso2To, firstNameTo, lastNameTo, null);
        Type localVarReturnType = new TypeToken<CorridorOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com) (asynchronously)
     * 
     * @param countryIso2From  (required)
     * @param firstNameFrom  (required)
     * @param lastNameFrom  (required)
     * @param countryIso2To  (required)
     * @param firstNameTo  (required)
     * @param lastNameTo  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Two classified names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call corridorAsync(String countryIso2From, String firstNameFrom, String lastNameFrom, String countryIso2To, String firstNameTo, String lastNameTo, final ApiCallback<CorridorOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = corridorValidateBeforeCall(countryIso2From, firstNameFrom, lastNameFrom, countryIso2To, firstNameTo, lastNameTo, _callback);
        Type localVarReturnType = new TypeToken<CorridorOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for corridorBatch
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified name pairs. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call corridorBatchCall(BatchCorridorIn batchCorridorIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchCorridorIn;

        // create path and map variables
        String localVarPath = "/api2/json/corridorBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call corridorBatchValidateBeforeCall(BatchCorridorIn batchCorridorIn, final ApiCallback _callback) throws ApiException {
        return corridorBatchCall(batchCorridorIn, _callback);

    }

    /**
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @return BatchCorridorOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified name pairs. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchCorridorOut corridorBatch(BatchCorridorIn batchCorridorIn) throws ApiException {
        ApiResponse<BatchCorridorOut> localVarResp = corridorBatchWithHttpInfo(batchCorridorIn);
        return localVarResp.getData();
    }

    /**
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @return ApiResponse&lt;BatchCorridorOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified name pairs. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchCorridorOut> corridorBatchWithHttpInfo(BatchCorridorIn batchCorridorIn) throws ApiException {
        okhttp3.Call localVarCall = corridorBatchValidateBeforeCall(batchCorridorIn, null);
        Type localVarReturnType = new TypeToken<BatchCorridorOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com) (asynchronously)
     * 
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified name pairs. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call corridorBatchAsync(BatchCorridorIn batchCorridorIn, final ApiCallback<BatchCorridorOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = corridorBatchValidateBeforeCall(batchCorridorIn, _callback);
        Type localVarReturnType = new TypeToken<BatchCorridorOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for country
     * @param personalNameFull  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call countryCall(String personalNameFull, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/country/{personalNameFull}"
            .replace("{" + "personalNameFull" + "}", localVarApiClient.escapeString(personalNameFull.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call countryValidateBeforeCall(String personalNameFull, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personalNameFull' is set
        if (personalNameFull == null) {
            throw new ApiException("Missing the required parameter 'personalNameFull' when calling country(Async)");
        }

        return countryCall(personalNameFull, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param personalNameFull  (required)
     * @return PersonalNameGeoOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public PersonalNameGeoOut country(String personalNameFull) throws ApiException {
        ApiResponse<PersonalNameGeoOut> localVarResp = countryWithHttpInfo(personalNameFull);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param personalNameFull  (required)
     * @return ApiResponse&lt;PersonalNameGeoOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonalNameGeoOut> countryWithHttpInfo(String personalNameFull) throws ApiException {
        okhttp3.Call localVarCall = countryValidateBeforeCall(personalNameFull, null);
        Type localVarReturnType = new TypeToken<PersonalNameGeoOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin. (asynchronously)
     * 
     * @param personalNameFull  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call countryAsync(String personalNameFull, final ApiCallback<PersonalNameGeoOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = countryValidateBeforeCall(personalNameFull, _callback);
        Type localVarReturnType = new TypeToken<PersonalNameGeoOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for countryBatch
     * @param batchPersonalNameIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call countryBatchCall(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameIn;

        // create path and map variables
        String localVarPath = "/api2/json/countryBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call countryBatchValidateBeforeCall(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback _callback) throws ApiException {
        return countryBatchCall(batchPersonalNameIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameGeoOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameGeoOut countryBatch(BatchPersonalNameIn batchPersonalNameIn) throws ApiException {
        ApiResponse<BatchPersonalNameGeoOut> localVarResp = countryBatchWithHttpInfo(batchPersonalNameIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchPersonalNameGeoOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameGeoOut> countryBatchWithHttpInfo(BatchPersonalNameIn batchPersonalNameIn) throws ApiException {
        okhttp3.Call localVarCall = countryBatchValidateBeforeCall(batchPersonalNameIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGeoOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin. (asynchronously)
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call countryBatchAsync(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback<BatchPersonalNameGeoOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = countryBatchValidateBeforeCall(batchPersonalNameIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGeoOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for diaspora
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A diaspora / ethnicity for given name and geography. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call diasporaCall(String countryIso2, String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/diaspora/{countryIso2}/{firstName}/{lastName}"
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()))
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call diasporaValidateBeforeCall(String countryIso2, String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling diaspora(Async)");
        }

        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling diaspora(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling diaspora(Async)");
        }

        return diasporaCall(countryIso2, firstName, lastName, _callback);

    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @return FirstLastNameDiasporaedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A diaspora / ethnicity for given name and geography. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameDiasporaedOut diaspora(String countryIso2, String firstName, String lastName) throws ApiException {
        ApiResponse<FirstLastNameDiasporaedOut> localVarResp = diasporaWithHttpInfo(countryIso2, firstName, lastName);
        return localVarResp.getData();
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @return ApiResponse&lt;FirstLastNameDiasporaedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A diaspora / ethnicity for given name and geography. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameDiasporaedOut> diasporaWithHttpInfo(String countryIso2, String firstName, String lastName) throws ApiException {
        okhttp3.Call localVarCall = diasporaValidateBeforeCall(countryIso2, firstName, lastName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameDiasporaedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) (asynchronously)
     * 
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A diaspora / ethnicity for given name and geography. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call diasporaAsync(String countryIso2, String firstName, String lastName, final ApiCallback<FirstLastNameDiasporaedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = diasporaValidateBeforeCall(countryIso2, firstName, lastName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameDiasporaedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for diasporaBatch
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of diaspora / ethnicity given a name and residency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call diasporaBatchCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/diasporaBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call diasporaBatchValidateBeforeCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        return diasporaBatchCall(batchFirstLastNameGeoIn, _callback);

    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchFirstLastNameDiasporaedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of diaspora / ethnicity given a name and residency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameDiasporaedOut diasporaBatch(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        ApiResponse<BatchFirstLastNameDiasporaedOut> localVarResp = diasporaBatchWithHttpInfo(batchFirstLastNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameDiasporaedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of diaspora / ethnicity given a name and residency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameDiasporaedOut> diasporaBatchWithHttpInfo(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = diasporaBatchValidateBeforeCall(batchFirstLastNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameDiasporaedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) (asynchronously)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of diaspora / ethnicity given a name and residency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call diasporaBatchAsync(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback<BatchFirstLastNameDiasporaedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = diasporaBatchValidateBeforeCall(batchFirstLastNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameDiasporaedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gender
     * @param firstName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderCall(String firstName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/gender/{firstName}"
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderValidateBeforeCall(String firstName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling gender(Async)");
        }

        return genderCall(firstName, _callback);

    }

    /**
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     * 
     * @param firstName  (required)
     * @return FirstLastNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameGenderedOut gender(String firstName) throws ApiException {
        ApiResponse<FirstLastNameGenderedOut> localVarResp = genderWithHttpInfo(firstName);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     * 
     * @param firstName  (required)
     * @return ApiResponse&lt;FirstLastNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameGenderedOut> genderWithHttpInfo(String firstName) throws ApiException {
        okhttp3.Call localVarCall = genderValidateBeforeCall(firstName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy. (asynchronously)
     * 
     * @param firstName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderAsync(String firstName, final ApiCallback<FirstLastNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderValidateBeforeCall(firstName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for gender1
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gender1Call(String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/gender/{firstName}/{lastName}"
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gender1ValidateBeforeCall(String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling gender1(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling gender1(Async)");
        }

        return gender1Call(firstName, lastName, _callback);

    }

    /**
     * Infer the likely gender of a name.
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @return FirstLastNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameGenderedOut gender1(String firstName, String lastName) throws ApiException {
        ApiResponse<FirstLastNameGenderedOut> localVarResp = gender1WithHttpInfo(firstName, lastName);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of a name.
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @return ApiResponse&lt;FirstLastNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameGenderedOut> gender1WithHttpInfo(String firstName, String lastName) throws ApiException {
        okhttp3.Call localVarCall = gender1ValidateBeforeCall(firstName, lastName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of a name. (asynchronously)
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gender1Async(String firstName, String lastName, final ApiCallback<FirstLastNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = gender1ValidateBeforeCall(firstName, lastName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderBatch
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderBatchCall(BatchFirstLastNameIn batchFirstLastNameIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameIn;

        // create path and map variables
        String localVarPath = "/api2/json/genderBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderBatchValidateBeforeCall(BatchFirstLastNameIn batchFirstLastNameIn, final ApiCallback _callback) throws ApiException {
        return genderBatchCall(batchFirstLastNameIn, _callback);

    }

    /**
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return BatchFirstLastNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameGenderedOut genderBatch(BatchFirstLastNameIn batchFirstLastNameIn) throws ApiException {
        ApiResponse<BatchFirstLastNameGenderedOut> localVarResp = genderBatchWithHttpInfo(batchFirstLastNameIn);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameGenderedOut> genderBatchWithHttpInfo(BatchFirstLastNameIn batchFirstLastNameIn) throws ApiException {
        okhttp3.Call localVarCall = genderBatchValidateBeforeCall(batchFirstLastNameIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context. (asynchronously)
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderBatchAsync(BatchFirstLastNameIn batchFirstLastNameIn, final ApiCallback<BatchFirstLastNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderBatchValidateBeforeCall(batchFirstLastNameIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderFull
     * @param fullName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullCall(String fullName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/genderFull/{fullName}"
            .replace("{" + "fullName" + "}", localVarApiClient.escapeString(fullName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderFullValidateBeforeCall(String fullName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fullName' is set
        if (fullName == null) {
            throw new ApiException("Missing the required parameter 'fullName' when calling genderFull(Async)");
        }

        return genderFullCall(fullName, _callback);

    }

    /**
     * Infer the likely gender of a full name, ex. John H. Smith
     * 
     * @param fullName  (required)
     * @return PersonalNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public PersonalNameGenderedOut genderFull(String fullName) throws ApiException {
        ApiResponse<PersonalNameGenderedOut> localVarResp = genderFullWithHttpInfo(fullName);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of a full name, ex. John H. Smith
     * 
     * @param fullName  (required)
     * @return ApiResponse&lt;PersonalNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonalNameGenderedOut> genderFullWithHttpInfo(String fullName) throws ApiException {
        okhttp3.Call localVarCall = genderFullValidateBeforeCall(fullName, null);
        Type localVarReturnType = new TypeToken<PersonalNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of a full name, ex. John H. Smith (asynchronously)
     * 
     * @param fullName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullAsync(String fullName, final ApiCallback<PersonalNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderFullValidateBeforeCall(fullName, _callback);
        Type localVarReturnType = new TypeToken<PersonalNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderFullBatch
     * @param batchPersonalNameIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullBatchCall(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameIn;

        // create path and map variables
        String localVarPath = "/api2/json/genderFullBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderFullBatchValidateBeforeCall(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback _callback) throws ApiException {
        return genderFullBatchCall(batchPersonalNameIn, _callback);

    }

    /**
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameGenderedOut genderFullBatch(BatchPersonalNameIn batchPersonalNameIn) throws ApiException {
        ApiResponse<BatchPersonalNameGenderedOut> localVarResp = genderFullBatchWithHttpInfo(batchPersonalNameIn);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchPersonalNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameGenderedOut> genderFullBatchWithHttpInfo(BatchPersonalNameIn batchPersonalNameIn) throws ApiException {
        okhttp3.Call localVarCall = genderFullBatchValidateBeforeCall(batchPersonalNameIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context. (asynchronously)
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullBatchAsync(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback<BatchPersonalNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderFullBatchValidateBeforeCall(batchPersonalNameIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderFullGeo
     * @param fullName  (required)
     * @param countryIso2  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullGeoCall(String fullName, String countryIso2, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/genderFullGeo/{fullName}/{countryIso2}"
            .replace("{" + "fullName" + "}", localVarApiClient.escapeString(fullName.toString()))
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderFullGeoValidateBeforeCall(String fullName, String countryIso2, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fullName' is set
        if (fullName == null) {
            throw new ApiException("Missing the required parameter 'fullName' when calling genderFullGeo(Async)");
        }

        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling genderFullGeo(Async)");
        }

        return genderFullGeoCall(fullName, countryIso2, _callback);

    }

    /**
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     * 
     * @param fullName  (required)
     * @param countryIso2  (required)
     * @return PersonalNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public PersonalNameGenderedOut genderFullGeo(String fullName, String countryIso2) throws ApiException {
        ApiResponse<PersonalNameGenderedOut> localVarResp = genderFullGeoWithHttpInfo(fullName, countryIso2);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     * 
     * @param fullName  (required)
     * @param countryIso2  (required)
     * @return ApiResponse&lt;PersonalNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonalNameGenderedOut> genderFullGeoWithHttpInfo(String fullName, String countryIso2) throws ApiException {
        okhttp3.Call localVarCall = genderFullGeoValidateBeforeCall(fullName, countryIso2, null);
        Type localVarReturnType = new TypeToken<PersonalNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of a full name, given a local context (ISO2 country code). (asynchronously)
     * 
     * @param fullName  (required)
     * @param countryIso2  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullGeoAsync(String fullName, String countryIso2, final ApiCallback<PersonalNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderFullGeoValidateBeforeCall(fullName, countryIso2, _callback);
        Type localVarReturnType = new TypeToken<PersonalNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderFullGeoBatch
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullGeoBatchCall(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/genderFullGeoBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderFullGeoBatchValidateBeforeCall(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback _callback) throws ApiException {
        return genderFullGeoBatchCall(batchPersonalNameGeoIn, _callback);

    }

    /**
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     * 
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @return BatchPersonalNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameGenderedOut genderFullGeoBatch(BatchPersonalNameGeoIn batchPersonalNameGeoIn) throws ApiException {
        ApiResponse<BatchPersonalNameGenderedOut> localVarResp = genderFullGeoBatchWithHttpInfo(batchPersonalNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     * 
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @return ApiResponse&lt;BatchPersonalNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameGenderedOut> genderFullGeoBatchWithHttpInfo(BatchPersonalNameGeoIn batchPersonalNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = genderFullGeoBatchValidateBeforeCall(batchPersonalNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code). (asynchronously)
     * 
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderFullGeoBatchAsync(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback<BatchPersonalNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderFullGeoBatchValidateBeforeCall(batchPersonalNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderGeo
     * @param firstName  (required)
     * @param lastName  (required)
     * @param countryIso2  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderGeoCall(String firstName, String lastName, String countryIso2, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/genderGeo/{firstName}/{lastName}/{countryIso2}"
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()))
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderGeoValidateBeforeCall(String firstName, String lastName, String countryIso2, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling genderGeo(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling genderGeo(Async)");
        }

        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling genderGeo(Async)");
        }

        return genderGeoCall(firstName, lastName, countryIso2, _callback);

    }

    /**
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param countryIso2  (required)
     * @return FirstLastNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameGenderedOut genderGeo(String firstName, String lastName, String countryIso2) throws ApiException {
        ApiResponse<FirstLastNameGenderedOut> localVarResp = genderGeoWithHttpInfo(firstName, lastName, countryIso2);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param countryIso2  (required)
     * @return ApiResponse&lt;FirstLastNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameGenderedOut> genderGeoWithHttpInfo(String firstName, String lastName, String countryIso2) throws ApiException {
        okhttp3.Call localVarCall = genderGeoValidateBeforeCall(firstName, lastName, countryIso2, null);
        Type localVarReturnType = new TypeToken<FirstLastNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of a name, given a local context (ISO2 country code). (asynchronously)
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param countryIso2  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A genderized name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderGeoAsync(String firstName, String lastName, String countryIso2, final ApiCallback<FirstLastNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderGeoValidateBeforeCall(firstName, lastName, countryIso2, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for genderGeoBatch
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderGeoBatchCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/genderGeoBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call genderGeoBatchValidateBeforeCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        return genderGeoBatchCall(batchFirstLastNameGeoIn, _callback);

    }

    /**
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     * 
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @return BatchFirstLastNameGenderedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameGenderedOut genderGeoBatch(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        ApiResponse<BatchFirstLastNameGenderedOut> localVarResp = genderGeoBatchWithHttpInfo(batchFirstLastNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     * 
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @return ApiResponse&lt;BatchFirstLastNameGenderedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameGenderedOut> genderGeoBatchWithHttpInfo(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = genderGeoBatchValidateBeforeCall(batchFirstLastNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameGenderedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code). (asynchronously)
     * 
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call genderGeoBatchAsync(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback<BatchFirstLastNameGenderedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = genderGeoBatchValidateBeforeCall(batchFirstLastNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameGenderedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for origin
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call originCall(String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/origin/{firstName}/{lastName}"
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call originValidateBeforeCall(String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling origin(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling origin(Async)");
        }

        return originCall(firstName, lastName, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @return FirstLastNameOriginedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameOriginedOut origin(String firstName, String lastName) throws ApiException {
        ApiResponse<FirstLastNameOriginedOut> localVarResp = originWithHttpInfo(firstName, lastName);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @return ApiResponse&lt;FirstLastNameOriginedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameOriginedOut> originWithHttpInfo(String firstName, String lastName) throws ApiException {
        okhttp3.Call localVarCall = originValidateBeforeCall(firstName, lastName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameOriginedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead. (asynchronously)
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call originAsync(String firstName, String lastName, final ApiCallback<FirstLastNameOriginedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = originValidateBeforeCall(firstName, lastName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameOriginedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for originBatch
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call originBatchCall(BatchFirstLastNameIn batchFirstLastNameIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameIn;

        // create path and map variables
        String localVarPath = "/api2/json/originBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call originBatchValidateBeforeCall(BatchFirstLastNameIn batchFirstLastNameIn, final ApiCallback _callback) throws ApiException {
        return originBatchCall(batchFirstLastNameIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return BatchFirstLastNameOriginedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameOriginedOut originBatch(BatchFirstLastNameIn batchFirstLastNameIn) throws ApiException {
        ApiResponse<BatchFirstLastNameOriginedOut> localVarResp = originBatchWithHttpInfo(batchFirstLastNameIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameOriginedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameOriginedOut> originBatchWithHttpInfo(BatchFirstLastNameIn batchFirstLastNameIn) throws ApiException {
        okhttp3.Call localVarCall = originBatchValidateBeforeCall(batchFirstLastNameIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameOriginedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context. (asynchronously)
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of genderized names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call originBatchAsync(BatchFirstLastNameIn batchFirstLastNameIn, final ApiCallback<BatchFirstLastNameOriginedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = originBatchValidateBeforeCall(batchFirstLastNameIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameOriginedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for parseName
     * @param nameFull  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameCall(String nameFull, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/parseName/{nameFull}"
            .replace("{" + "nameFull" + "}", localVarApiClient.escapeString(nameFull.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call parseNameValidateBeforeCall(String nameFull, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nameFull' is set
        if (nameFull == null) {
            throw new ApiException("Missing the required parameter 'nameFull' when calling parseName(Async)");
        }

        return parseNameCall(nameFull, _callback);

    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. 
     * 
     * @param nameFull  (required)
     * @return PersonalNameParsedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public PersonalNameParsedOut parseName(String nameFull) throws ApiException {
        ApiResponse<PersonalNameParsedOut> localVarResp = parseNameWithHttpInfo(nameFull);
        return localVarResp.getData();
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. 
     * 
     * @param nameFull  (required)
     * @return ApiResponse&lt;PersonalNameParsedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonalNameParsedOut> parseNameWithHttpInfo(String nameFull) throws ApiException {
        okhttp3.Call localVarCall = parseNameValidateBeforeCall(nameFull, null);
        Type localVarReturnType = new TypeToken<PersonalNameParsedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.  (asynchronously)
     * 
     * @param nameFull  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameAsync(String nameFull, final ApiCallback<PersonalNameParsedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = parseNameValidateBeforeCall(nameFull, _callback);
        Type localVarReturnType = new TypeToken<PersonalNameParsedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for parseNameBatch
     * @param batchPersonalNameIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameBatchCall(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameIn;

        // create path and map variables
        String localVarPath = "/api2/json/parseNameBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call parseNameBatchValidateBeforeCall(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback _callback) throws ApiException {
        return parseNameBatchCall(batchPersonalNameIn, _callback);

    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameParsedOut parseNameBatch(BatchPersonalNameIn batchPersonalNameIn) throws ApiException {
        ApiResponse<BatchPersonalNameParsedOut> localVarResp = parseNameBatchWithHttpInfo(batchPersonalNameIn);
        return localVarResp.getData();
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchPersonalNameParsedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameParsedOut> parseNameBatchWithHttpInfo(BatchPersonalNameIn batchPersonalNameIn) throws ApiException {
        okhttp3.Call localVarCall = parseNameBatchValidateBeforeCall(batchPersonalNameIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameParsedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. (asynchronously)
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameBatchAsync(BatchPersonalNameIn batchPersonalNameIn, final ApiCallback<BatchPersonalNameParsedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = parseNameBatchValidateBeforeCall(batchPersonalNameIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameParsedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for parseNameGeo
     * @param nameFull  (required)
     * @param countryIso2  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameGeoCall(String nameFull, String countryIso2, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/parseName/{nameFull}/{countryIso2}"
            .replace("{" + "nameFull" + "}", localVarApiClient.escapeString(nameFull.toString()))
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call parseNameGeoValidateBeforeCall(String nameFull, String countryIso2, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nameFull' is set
        if (nameFull == null) {
            throw new ApiException("Missing the required parameter 'nameFull' when calling parseNameGeo(Async)");
        }

        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling parseNameGeo(Async)");
        }

        return parseNameGeoCall(nameFull, countryIso2, _callback);

    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     * 
     * @param nameFull  (required)
     * @param countryIso2  (required)
     * @return PersonalNameParsedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public PersonalNameParsedOut parseNameGeo(String nameFull, String countryIso2) throws ApiException {
        ApiResponse<PersonalNameParsedOut> localVarResp = parseNameGeoWithHttpInfo(nameFull, countryIso2);
        return localVarResp.getData();
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     * 
     * @param nameFull  (required)
     * @param countryIso2  (required)
     * @return ApiResponse&lt;PersonalNameParsedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonalNameParsedOut> parseNameGeoWithHttpInfo(String nameFull, String countryIso2) throws ApiException {
        okhttp3.Call localVarCall = parseNameGeoValidateBeforeCall(nameFull, countryIso2, null);
        Type localVarReturnType = new TypeToken<PersonalNameParsedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context. (asynchronously)
     * 
     * @param nameFull  (required)
     * @param countryIso2  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A origined name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameGeoAsync(String nameFull, String countryIso2, final ApiCallback<PersonalNameParsedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = parseNameGeoValidateBeforeCall(nameFull, countryIso2, _callback);
        Type localVarReturnType = new TypeToken<PersonalNameParsedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for parseNameGeoBatch
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameGeoBatchCall(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/parseNameGeoBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call parseNameGeoBatchValidateBeforeCall(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback _callback) throws ApiException {
        return parseNameGeoBatchCall(batchPersonalNameGeoIn, _callback);

    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision. 
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameParsedOut parseNameGeoBatch(BatchPersonalNameGeoIn batchPersonalNameGeoIn) throws ApiException {
        ApiResponse<BatchPersonalNameParsedOut> localVarResp = parseNameGeoBatchWithHttpInfo(batchPersonalNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision. 
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchPersonalNameParsedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameParsedOut> parseNameGeoBatchWithHttpInfo(BatchPersonalNameGeoIn batchPersonalNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = parseNameGeoBatchValidateBeforeCall(batchPersonalNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameParsedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision.  (asynchronously)
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of parsed names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call parseNameGeoBatchAsync(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback<BatchPersonalNameParsedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = parseNameGeoBatchValidateBeforeCall(batchPersonalNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameParsedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for religion2
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religion2Call(String countryIso2, String subDivisionIso31662, String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/religion/{countryIso2}/{subDivisionIso31662}/{firstName}/{lastName}"
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()))
            .replace("{" + "subDivisionIso31662" + "}", localVarApiClient.escapeString(subDivisionIso31662.toString()))
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call religion2ValidateBeforeCall(String countryIso2, String subDivisionIso31662, String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling religion2(Async)");
        }

        // verify the required parameter 'subDivisionIso31662' is set
        if (subDivisionIso31662 == null) {
            throw new ApiException("Missing the required parameter 'subDivisionIso31662' when calling religion2(Async)");
        }

        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling religion2(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling religion2(Async)");
        }

        return religion2Call(countryIso2, subDivisionIso31662, firstName, lastName, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @return FirstLastNameReligionedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameReligionedOut religion2(String countryIso2, String subDivisionIso31662, String firstName, String lastName) throws ApiException {
        ApiResponse<FirstLastNameReligionedOut> localVarResp = religion2WithHttpInfo(countryIso2, subDivisionIso31662, firstName, lastName);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @return ApiResponse&lt;FirstLastNameReligionedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameReligionedOut> religion2WithHttpInfo(String countryIso2, String subDivisionIso31662, String firstName, String lastName) throws ApiException {
        okhttp3.Call localVarCall = religion2ValidateBeforeCall(countryIso2, subDivisionIso31662, firstName, lastName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameReligionedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version). (asynchronously)
     * 
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religion2Async(String countryIso2, String subDivisionIso31662, String firstName, String lastName, final ApiCallback<FirstLastNameReligionedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = religion2ValidateBeforeCall(countryIso2, subDivisionIso31662, firstName, lastName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameReligionedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for religionBatch
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religionBatchCall(BatchFirstLastNameGeoSubdivisionIn batchFirstLastNameGeoSubdivisionIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameGeoSubdivisionIn;

        // create path and map variables
        String localVarPath = "/api2/json/religionBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call religionBatchValidateBeforeCall(BatchFirstLastNameGeoSubdivisionIn batchFirstLastNameGeoSubdivisionIn, final ApiCallback _callback) throws ApiException {
        return religionBatchCall(batchFirstLastNameGeoSubdivisionIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     * 
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @return BatchFirstLastNameReligionedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameReligionedOut religionBatch(BatchFirstLastNameGeoSubdivisionIn batchFirstLastNameGeoSubdivisionIn) throws ApiException {
        ApiResponse<BatchFirstLastNameReligionedOut> localVarResp = religionBatchWithHttpInfo(batchFirstLastNameGeoSubdivisionIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     * 
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameReligionedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameReligionedOut> religionBatchWithHttpInfo(BatchFirstLastNameGeoSubdivisionIn batchFirstLastNameGeoSubdivisionIn) throws ApiException {
        okhttp3.Call localVarCall = religionBatchValidateBeforeCall(batchFirstLastNameGeoSubdivisionIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameReligionedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently. (asynchronously)
     * 
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religionBatchAsync(BatchFirstLastNameGeoSubdivisionIn batchFirstLastNameGeoSubdivisionIn, final ApiCallback<BatchFirstLastNameReligionedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = religionBatchValidateBeforeCall(batchFirstLastNameGeoSubdivisionIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameReligionedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for religionFull
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param personalNameFull  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religionFullCall(String countryIso2, String subDivisionIso31662, String personalNameFull, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/religionFull/{countryIso2}/{subDivisionIso31662}/{personalNameFull}"
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()))
            .replace("{" + "subDivisionIso31662" + "}", localVarApiClient.escapeString(subDivisionIso31662.toString()))
            .replace("{" + "personalNameFull" + "}", localVarApiClient.escapeString(personalNameFull.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call religionFullValidateBeforeCall(String countryIso2, String subDivisionIso31662, String personalNameFull, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling religionFull(Async)");
        }

        // verify the required parameter 'subDivisionIso31662' is set
        if (subDivisionIso31662 == null) {
            throw new ApiException("Missing the required parameter 'subDivisionIso31662' when calling religionFull(Async)");
        }

        // verify the required parameter 'personalNameFull' is set
        if (personalNameFull == null) {
            throw new ApiException("Missing the required parameter 'personalNameFull' when calling religionFull(Async)");
        }

        return religionFullCall(countryIso2, subDivisionIso31662, personalNameFull, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param personalNameFull  (required)
     * @return PersonalNameReligionedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public PersonalNameReligionedOut religionFull(String countryIso2, String subDivisionIso31662, String personalNameFull) throws ApiException {
        ApiResponse<PersonalNameReligionedOut> localVarResp = religionFullWithHttpInfo(countryIso2, subDivisionIso31662, personalNameFull);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param personalNameFull  (required)
     * @return ApiResponse&lt;PersonalNameReligionedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonalNameReligionedOut> religionFullWithHttpInfo(String countryIso2, String subDivisionIso31662, String personalNameFull) throws ApiException {
        okhttp3.Call localVarCall = religionFullValidateBeforeCall(countryIso2, subDivisionIso31662, personalNameFull, null);
        Type localVarReturnType = new TypeToken<PersonalNameReligionedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version). (asynchronously)
     * 
     * @param countryIso2  (required)
     * @param subDivisionIso31662  (required)
     * @param personalNameFull  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A religion-coded name. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religionFullAsync(String countryIso2, String subDivisionIso31662, String personalNameFull, final ApiCallback<PersonalNameReligionedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = religionFullValidateBeforeCall(countryIso2, subDivisionIso31662, personalNameFull, _callback);
        Type localVarReturnType = new TypeToken<PersonalNameReligionedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for religionFullBatch
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religionFullBatchCall(BatchPersonalNameGeoSubdivisionIn batchPersonalNameGeoSubdivisionIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameGeoSubdivisionIn;

        // create path and map variables
        String localVarPath = "/api2/json/religionFullBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call religionFullBatchValidateBeforeCall(BatchPersonalNameGeoSubdivisionIn batchPersonalNameGeoSubdivisionIn, final ApiCallback _callback) throws ApiException {
        return religionFullBatchCall(batchPersonalNameGeoSubdivisionIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     * 
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @return BatchPersonalNameReligionedOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameReligionedOut religionFullBatch(BatchPersonalNameGeoSubdivisionIn batchPersonalNameGeoSubdivisionIn) throws ApiException {
        ApiResponse<BatchPersonalNameReligionedOut> localVarResp = religionFullBatchWithHttpInfo(batchPersonalNameGeoSubdivisionIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     * 
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchPersonalNameReligionedOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameReligionedOut> religionFullBatchWithHttpInfo(BatchPersonalNameGeoSubdivisionIn batchPersonalNameGeoSubdivisionIn) throws ApiException {
        okhttp3.Call localVarCall = religionFullBatchValidateBeforeCall(batchPersonalNameGeoSubdivisionIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameReligionedOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently. (asynchronously)
     * 
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of religion-coded names. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call religionFullBatchAsync(BatchPersonalNameGeoSubdivisionIn batchPersonalNameGeoSubdivisionIn, final ApiCallback<BatchPersonalNameReligionedOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = religionFullBatchValidateBeforeCall(batchPersonalNameGeoSubdivisionIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameReligionedOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for subclassification
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationCall(String countryIso2, String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/subclassification/{countryIso2}/{firstName}/{lastName}"
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()))
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call subclassificationValidateBeforeCall(String countryIso2, String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling subclassification(Async)");
        }

        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling subclassification(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling subclassification(Async)");
        }

        return subclassificationCall(countryIso2, firstName, lastName, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @return FirstLastNameGeoSubclassificationOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameGeoSubclassificationOut subclassification(String countryIso2, String firstName, String lastName) throws ApiException {
        ApiResponse<FirstLastNameGeoSubclassificationOut> localVarResp = subclassificationWithHttpInfo(countryIso2, firstName, lastName);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @return ApiResponse&lt;FirstLastNameGeoSubclassificationOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameGeoSubclassificationOut> subclassificationWithHttpInfo(String countryIso2, String firstName, String lastName) throws ApiException {
        okhttp3.Call localVarCall = subclassificationValidateBeforeCall(countryIso2, firstName, lastName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameGeoSubclassificationOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;). (asynchronously)
     * 
     * @param countryIso2  (required)
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationAsync(String countryIso2, String firstName, String lastName, final ApiCallback<FirstLastNameGeoSubclassificationOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = subclassificationValidateBeforeCall(countryIso2, firstName, lastName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameGeoSubclassificationOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for subclassificationBatch
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationBatchCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/subclassificationBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call subclassificationBatchValidateBeforeCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        return subclassificationBatchCall(batchFirstLastNameGeoIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchFirstLastNameGeoSubclassificationOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameGeoSubclassificationOut subclassificationBatch(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        ApiResponse<BatchFirstLastNameGeoSubclassificationOut> localVarResp = subclassificationBatchWithHttpInfo(batchFirstLastNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameGeoSubclassificationOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameGeoSubclassificationOut> subclassificationBatchWithHttpInfo(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = subclassificationBatchValidateBeforeCall(batchFirstLastNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameGeoSubclassificationOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;). (asynchronously)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationBatchAsync(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback<BatchFirstLastNameGeoSubclassificationOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = subclassificationBatchValidateBeforeCall(batchFirstLastNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameGeoSubclassificationOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for subclassificationFull
     * @param countryIso2  (required)
     * @param fullName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationFullCall(String countryIso2, String fullName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/subclassificationFull/{countryIso2}/{fullName}"
            .replace("{" + "countryIso2" + "}", localVarApiClient.escapeString(countryIso2.toString()))
            .replace("{" + "fullName" + "}", localVarApiClient.escapeString(fullName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call subclassificationFullValidateBeforeCall(String countryIso2, String fullName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryIso2' is set
        if (countryIso2 == null) {
            throw new ApiException("Missing the required parameter 'countryIso2' when calling subclassificationFull(Async)");
        }

        // verify the required parameter 'fullName' is set
        if (fullName == null) {
            throw new ApiException("Missing the required parameter 'fullName' when calling subclassificationFull(Async)");
        }

        return subclassificationFullCall(countryIso2, fullName, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2  (required)
     * @param fullName  (required)
     * @return FirstLastNameGeoSubclassificationOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameGeoSubclassificationOut subclassificationFull(String countryIso2, String fullName) throws ApiException {
        ApiResponse<FirstLastNameGeoSubclassificationOut> localVarResp = subclassificationFullWithHttpInfo(countryIso2, fullName);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2  (required)
     * @param fullName  (required)
     * @return ApiResponse&lt;FirstLastNameGeoSubclassificationOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameGeoSubclassificationOut> subclassificationFullWithHttpInfo(String countryIso2, String fullName) throws ApiException {
        okhttp3.Call localVarCall = subclassificationFullValidateBeforeCall(countryIso2, fullName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameGeoSubclassificationOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;). (asynchronously)
     * 
     * @param countryIso2  (required)
     * @param fullName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A classified name at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationFullAsync(String countryIso2, String fullName, final ApiCallback<FirstLastNameGeoSubclassificationOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = subclassificationFullValidateBeforeCall(countryIso2, fullName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameGeoSubclassificationOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for subclassificationFullBatch
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationFullBatchCall(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPersonalNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/subclassificationFullBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call subclassificationFullBatchValidateBeforeCall(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback _callback) throws ApiException {
        return subclassificationFullBatchCall(batchPersonalNameGeoIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchPersonalNameGeoSubclassificationOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchPersonalNameGeoSubclassificationOut subclassificationFullBatch(BatchPersonalNameGeoIn batchPersonalNameGeoIn) throws ApiException {
        ApiResponse<BatchPersonalNameGeoSubclassificationOut> localVarResp = subclassificationFullBatchWithHttpInfo(batchPersonalNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchPersonalNameGeoSubclassificationOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPersonalNameGeoSubclassificationOut> subclassificationFullBatchWithHttpInfo(BatchPersonalNameGeoIn batchPersonalNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = subclassificationFullBatchValidateBeforeCall(batchPersonalNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGeoSubclassificationOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;). (asynchronously)
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of classified names at a sub-country level. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subclassificationFullBatchAsync(BatchPersonalNameGeoIn batchPersonalNameGeoIn, final ApiCallback<BatchPersonalNameGeoSubclassificationOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = subclassificationFullBatchValidateBeforeCall(batchPersonalNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchPersonalNameGeoSubclassificationOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usRaceEthnicity
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usRaceEthnicityCall(String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/usRaceEthnicity/{firstName}/{lastName}"
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usRaceEthnicityValidateBeforeCall(String firstName, String lastName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling usRaceEthnicity(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling usRaceEthnicity(Async)");
        }

        return usRaceEthnicityCall(firstName, lastName, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @return FirstLastNameUSRaceEthnicityOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameUSRaceEthnicityOut usRaceEthnicity(String firstName, String lastName) throws ApiException {
        ApiResponse<FirstLastNameUSRaceEthnicityOut> localVarResp = usRaceEthnicityWithHttpInfo(firstName, lastName);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @return ApiResponse&lt;FirstLastNameUSRaceEthnicityOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameUSRaceEthnicityOut> usRaceEthnicityWithHttpInfo(String firstName, String lastName) throws ApiException {
        okhttp3.Call localVarCall = usRaceEthnicityValidateBeforeCall(firstName, lastName, null);
        Type localVarReturnType = new TypeToken<FirstLastNameUSRaceEthnicityOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander). (asynchronously)
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usRaceEthnicityAsync(String firstName, String lastName, final ApiCallback<FirstLastNameUSRaceEthnicityOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = usRaceEthnicityValidateBeforeCall(firstName, lastName, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameUSRaceEthnicityOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usRaceEthnicityBatch
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usRaceEthnicityBatchCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameGeoIn;

        // create path and map variables
        String localVarPath = "/api2/json/usRaceEthnicityBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usRaceEthnicityBatchValidateBeforeCall(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback _callback) throws ApiException {
        return usRaceEthnicityBatchCall(batchFirstLastNameGeoIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchFirstLastNameUSRaceEthnicityOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameUSRaceEthnicityOut usRaceEthnicityBatch(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        ApiResponse<BatchFirstLastNameUSRaceEthnicityOut> localVarResp = usRaceEthnicityBatchWithHttpInfo(batchFirstLastNameGeoIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameUSRaceEthnicityOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameUSRaceEthnicityOut> usRaceEthnicityBatchWithHttpInfo(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn) throws ApiException {
        okhttp3.Call localVarCall = usRaceEthnicityBatchValidateBeforeCall(batchFirstLastNameGeoIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameUSRaceEthnicityOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander). (asynchronously)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usRaceEthnicityBatchAsync(BatchFirstLastNameGeoIn batchFirstLastNameGeoIn, final ApiCallback<BatchFirstLastNameUSRaceEthnicityOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = usRaceEthnicityBatchValidateBeforeCall(batchFirstLastNameGeoIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameUSRaceEthnicityOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usRaceEthnicityZIP5
     * @param firstName  (required)
     * @param lastName  (required)
     * @param zip5Code  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usRaceEthnicityZIP5Call(String firstName, String lastName, String zip5Code, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api2/json/usRaceEthnicityZIP5/{firstName}/{lastName}/{zip5Code}"
            .replace("{" + "firstName" + "}", localVarApiClient.escapeString(firstName.toString()))
            .replace("{" + "lastName" + "}", localVarApiClient.escapeString(lastName.toString()))
            .replace("{" + "zip5Code" + "}", localVarApiClient.escapeString(zip5Code.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usRaceEthnicityZIP5ValidateBeforeCall(String firstName, String lastName, String zip5Code, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'firstName' is set
        if (firstName == null) {
            throw new ApiException("Missing the required parameter 'firstName' when calling usRaceEthnicityZIP5(Async)");
        }

        // verify the required parameter 'lastName' is set
        if (lastName == null) {
            throw new ApiException("Missing the required parameter 'lastName' when calling usRaceEthnicityZIP5(Async)");
        }

        // verify the required parameter 'zip5Code' is set
        if (zip5Code == null) {
            throw new ApiException("Missing the required parameter 'zip5Code' when calling usRaceEthnicityZIP5(Async)");
        }

        return usRaceEthnicityZIP5Call(firstName, lastName, zip5Code, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param zip5Code  (required)
     * @return FirstLastNameUSRaceEthnicityOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public FirstLastNameUSRaceEthnicityOut usRaceEthnicityZIP5(String firstName, String lastName, String zip5Code) throws ApiException {
        ApiResponse<FirstLastNameUSRaceEthnicityOut> localVarResp = usRaceEthnicityZIP5WithHttpInfo(firstName, lastName, zip5Code);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param zip5Code  (required)
     * @return ApiResponse&lt;FirstLastNameUSRaceEthnicityOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FirstLastNameUSRaceEthnicityOut> usRaceEthnicityZIP5WithHttpInfo(String firstName, String lastName, String zip5Code) throws ApiException {
        okhttp3.Call localVarCall = usRaceEthnicityZIP5ValidateBeforeCall(firstName, lastName, zip5Code, null);
        Type localVarReturnType = new TypeToken<FirstLastNameUSRaceEthnicityOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander). (asynchronously)
     * 
     * @param firstName  (required)
     * @param lastName  (required)
     * @param zip5Code  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usRaceEthnicityZIP5Async(String firstName, String lastName, String zip5Code, final ApiCallback<FirstLastNameUSRaceEthnicityOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = usRaceEthnicityZIP5ValidateBeforeCall(firstName, lastName, zip5Code, _callback);
        Type localVarReturnType = new TypeToken<FirstLastNameUSRaceEthnicityOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usZipRaceEthnicityBatch
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usZipRaceEthnicityBatchCall(BatchFirstLastNameGeoZippedIn batchFirstLastNameGeoZippedIn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchFirstLastNameGeoZippedIn;

        // create path and map variables
        String localVarPath = "/api2/json/usZipRaceEthnicityBatch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usZipRaceEthnicityBatchValidateBeforeCall(BatchFirstLastNameGeoZippedIn batchFirstLastNameGeoZippedIn, final ApiCallback _callback) throws ApiException {
        return usZipRaceEthnicityBatchCall(batchFirstLastNameGeoZippedIn, _callback);

    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @return BatchFirstLastNameUSRaceEthnicityOut
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public BatchFirstLastNameUSRaceEthnicityOut usZipRaceEthnicityBatch(BatchFirstLastNameGeoZippedIn batchFirstLastNameGeoZippedIn) throws ApiException {
        ApiResponse<BatchFirstLastNameUSRaceEthnicityOut> localVarResp = usZipRaceEthnicityBatchWithHttpInfo(batchFirstLastNameGeoZippedIn);
        return localVarResp.getData();
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @return ApiResponse&lt;BatchFirstLastNameUSRaceEthnicityOut&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchFirstLastNameUSRaceEthnicityOut> usZipRaceEthnicityBatchWithHttpInfo(BatchFirstLastNameGeoZippedIn batchFirstLastNameGeoZippedIn) throws ApiException {
        okhttp3.Call localVarCall = usZipRaceEthnicityBatchValidateBeforeCall(batchFirstLastNameGeoZippedIn, null);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameUSRaceEthnicityOut>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander). (asynchronously)
     * 
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino), AI_AN (American Indian or Alaskan Native*) and PI (Pacific Islander*). *optionally </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or incorrect API Key </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Email not Verified, or API Limit Reached, or API Key Disabled </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request (ex. too many names) </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usZipRaceEthnicityBatchAsync(BatchFirstLastNameGeoZippedIn batchFirstLastNameGeoZippedIn, final ApiCallback<BatchFirstLastNameUSRaceEthnicityOut> _callback) throws ApiException {

        okhttp3.Call localVarCall = usZipRaceEthnicityBatchValidateBeforeCall(batchFirstLastNameGeoZippedIn, _callback);
        Type localVarReturnType = new TypeToken<BatchFirstLastNameUSRaceEthnicityOut>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
